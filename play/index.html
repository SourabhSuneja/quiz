<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Quiz | Powered by Sourabh Suneja</title>
<style>
  body {
    background-color: black;
    color: white;
    font-family: Arial, sans-serif;
    font-size: 18px;
    background-image: url('images/night.jpg');
    background-size: contain;
    background-position: center;
    background-attachment: fixed;
  }

  .overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.3);
  z-index: -1;
}

  .container {
    max-width: 700px;
    margin: 50px auto;
    padding: 20px;
    border: 3px solid white;
    border-radius: 10px;
    text-align: center;
    background: black;
  }
  h1 {
    text-align: center;
    font-size: 24px;
  }
  .question {
    margin-bottom: 20px;
    font-size: 20px;
  }
  .buttons {
    display: flex;
    justify-content: center;
    flex-wrap: wrap;
  }
  button {
    margin: 10px;
    padding: 10px 20px;
    background-color: #1E90FF; /* Dark blue shade */
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: background-color 0.3s;
    font-size: 18px;
  }
  button:hover {
    background-color: #4682B4; /* Lighter shade on hover */
  }
  footer {
    margin-top: 24px;
    font-size: 18px;
  }
  .chart-container {
    width: 100%;
    max-width: 600px;
    margin: 50px auto;
    padding: 12px;
    border: 3px solid white;
    border-radius: 10px;
    box-sizing: border-box;
    background: black;
  }
  .bar {
    padding: 5px;
    margin-bottom: 5px;
    border-radius: 5px;
    display: flex;
    align-items: center;
  }
  .bar-text {
    margin-right: 10px;
  }
  .slider {
    -webkit-appearance: none;
    width: 80%;
    max-width: 350px;
    height: 15px;
    border-radius: 5px;
    background: #4e8af1;
    outline: none;
    opacity: 1;
    -webkit-transition: .2s;
    transition: opacity .2s;
  }
  
  .slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 25px;
    height: 25px;
    border-radius: 50%;
    background: #4caf50;
    cursor: pointer;
  }
  
  .slider::-moz-range-thumb {
    width: 25px;
    height: 25px;
    border-radius: 50%;
    background: #4caf50;
    cursor: pointer;
  }

  /* CSS for custom dialog box */
    .custom-dialog {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: #ffffff;
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        z-index: 9999;
    }

    .custom-dialog-title {
        font-size: 20px;
        margin-bottom: 10px;
        text-align: center;
        color: #333333;
    }

    .custom-dialog-options {
        list-style: none;
        padding: 0;
        margin: 0;
        max-height: 200px; /* Set max height for scrollability */
        overflow-y: auto; /* Enable vertical scrolling */
    }

    .custom-dialog-option {
        padding: 10px;
        cursor: pointer;
        transition: background-color 0.3s ease, color 0.3s ease;
        color: #000;
    }

    .custom-dialog-option:hover {
        background-color: #5cb85c; /* Beautiful green color */
        color: #ffffff; /* Change text color on hover */
    }

    .custom-dialog-close {
    position: absolute;
    top: 18px;
    right: 18px;
    cursor: pointer;
    font-size: 22px;
    color: #777777;
    }

    /* Mobile styles */
    @media only screen and (max-width: 600px) {
        .custom-dialog {
            width: 80%;
        }
    }
    /* Style for floating button */
    #scoresButton {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background-color: #007bff;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
      z-index: 1000;
    }
    
    /* Style for overlay table */
    #scoreTableContainer {
      display: none;
      position: fixed;
      bottom: 80px;
      right: 20px;
      background-color: #111; /* Change background color to dark */
      border: 1px solid #666; /* Adjust border color */
      border-radius: 10px;
      padding: 20px;
      z-index: 999;
      box-shadow: 0px 0px 10px rgba(255, 255, 255, 0.1); /* Add box shadow effect */
      max-width: 90%; /* Limit maximum width for small screens */
      overflow-x: auto; /* Add horizontal scroll for small screens */
      max-height: 70vh; /* Limit maximum height and enable vertical scrolling */
      overflow-y: auto; /* Enable vertical scrolling */
    }
    
    /* Style for table */
    #scoreTableContainer table {
      width: 100%; /* Make the table width 100% */
      border-collapse: collapse;
      margin-top: 10px;
    }
    
    #scoreTableContainer th, #scoreTableContainer td {
      padding: 10px;
      text-align: center;
      border-bottom: 1px solid #666; /* Adjust border color */
      color: white; /* Change text color to white */
    }
    
    #scoreTableContainer th {
      background-color: #007bff;
    }
    
    /* Alternate row background color for better readability */
    #scoreTableContainer tbody tr:nth-child(even) {
      background-color: #222; /* Darker background for alternate rows */
    }
    
    #teamScoresHeading {
       font-size: 20px;
    }

    #scoreTableContainer table td:first-child, #scoreTableContainer table th:first-child {
      text-align: left;
    }
    
    /* Media query for small screens */
    @media (max-width: 600px) {
      #scoreTableContainer {
        max-width: calc(100% - 32px); 
      }
    }

    #animation-container {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: none;
      z-index: 9999;
    }

    @keyframes pop-up {
      0% {transform: scale(0) translateY(100px);}
      50% {transform: scale(1.1) translateY(-50px);}
      100% {transform: scale(1) translateY(0);}
    }

    .animation {
      animation: pop-up 1s cubic-bezier(0.68, -0.55, 0.265, 1.55);
      font-size: 24px;
      font-weight: bold;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
      border-radius: 10px;
      padding: 20px;
      box-shadow: 0px 0px 20px rgba(0,0,0,0.3);
    }

    /* Media query for small screens */
    @media (max-width: 600px) {
      .animation-fs-reduced {
        font-size: 18px;
      }
    }

    .correct {
      color: white;
      background-color: RGB(21,194,21);
    }

    .wrong {
      color: white;
      background-color: rgba(178, 16, 16, 1);
    }

    .half-correct, .answer {
      color: white;
      background-color: orange;
    }

    #mediaContainer {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    z-index: 9999;
  }
  #player {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
  }
  .closeButton {
    position: absolute;
    top: 10px;
    right: 10px;
    cursor: pointer;
    color: #fff;
    font-size: 24px;
  }
  #audioText {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: #fff;
    font-size: 24px;
    font-weight: bold;
    display: none;
  }
  #playClipBtn {
    display: none;
    background: darkcyan;
  }

  #playClipBtn:hover {
    background: #086767;
  }


.loading-animation {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}

#mediaContainer img {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    max-width: 100%;
    max-height: 100%;
}

#startScreen {
    display: flex;
    justify-content: center;
    align-items: center;
    position: fixed;
    top: 0;
    left: 0;
    height: 100%;
    width: 100%;
    z-index: 99999;
    background: black;
    color: white;
    text-align: center;
    padding: 12px;
    box-sizing: border-box;
}

#startScreenInner {
    text-align: center;
    padding: 20px;
    border: 3px solid white;
    border-radius: 10px;
    box-sizing: border-box;
}


.carousel, .carousel-inner, .card, #card-picker {
    box-sizing: border-box;
  }
 
  .carousel-container {
    width: 100%;
    max-width: 700px;
    margin: 0 auto;
    overflow: hidden;
    padding: 18px;
    position: relative;
  }

  .carousel {
    display: flex;
    transition: transform 0.5s ease-in-out;
  }

  .carousel-item {
    flex: 0 0 auto;
    width: 180px;
    padding: 20px;
    margin: 0 10px;
    border-radius: 10px;
    background-color: #333;
    text-align: center;
    transition: all 0.3s ease;
    cursor: pointer;
    position: relative;
  }

  .carousel-item::before {
    content: '';
    position: absolute;
    top: 0;
    bottom: 0;
    left: -10px; /* Half the gutter width */
    right: -10px; /* Half the gutter width */
  }

  .carousel-item.active {
    background-color: #555;
    transform: scale(1.1);
  }

  #card-picker {
    margin-top: 40px;
    text-align: center;
    z-index: 50000;
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: black;
  }

  #card-picker h1 {
    font-size: 22px;
  }

  #card-picker h2 {
    font-size: 20px;
  }

  #cardsIntro {
    text-align: center;
    color: RGB(230,230,230);
    max-width: 600px;
    margin: auto;
    padding-bottom: 16px;
  }

  #selectCardBtn {
    display: inline-block;
    margin-top: 26px;
    background-color: #007bff;
    color: white; 
    border: none; 
    border-radius: 5px;
    padding: 10px 20px; 
    font-size: 16px; 
    transition: background-color 0.3s ease; 
  }

  #selectCardBtn:hover {
     background-color: #0056b3;
     cursor: pointer;
  }
  #card-picker-close-btn {
     color: white;
     font-size: 30px;
     position: absolute;
     top: 12px;
     right: 12px;
     cursor: pointer;
  }
  .cardQRemaining {
     font-weight: bold;
  }
  #selectCardBtn:disabled {
    background-color: rgba(135, 169, 208, 0.5);  /* Faded blue color */
    cursor: not-allowed; 
}

        /* Style for the custom modal */
        .cm-modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7); /* Darker background */
            z-index: 100000;
        }

        .cm-modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #fff; /* Lighter background */
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2); /* Softer shadow */
            text-align: center;
            width: 320px;
            max-width: 90%; /* Responsive size */
            font-family: Arial, sans-serif;
        }

        .cm-modal-content h3 {
            margin-bottom: 15px;
            font-size: 18px;
            color: #333;
        }

        .cm-modal-content input, .cm-modal-content select {
            width: 100%;
            padding: 12px;
            margin-top: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            box-sizing: border-box;
            font-size: 16px;
            transition: border 0.3s;
        }

        .cm-modal-content input:focus, .cm-modal-content select:focus {
            border-color: #4CAF50; /* Focus state color */
            outline: none;
        }

        .cm-modal-content button {
            margin-top: 15px;
            padding: 12px 24px;
            background-color: #4CAF50; /* Green button */
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s ease;
        }

        .cm-modal-content button:hover {
            background-color: #45a049; /* Darker green on hover */
        }

        .cm-modal-content button:focus {
            outline: none;
        }

        .cm-modal-content input::placeholder {
            color: #999; /* Placeholder color */
        }

    /* Full-screen result submission overlay */
    .sr-overlay {
      display: none; /* Hidden by default */
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 1); /* Dark overlay */
      z-index: 1000000; /* Make sure it's on top */
      justify-content: center;
      align-items: center;
      color: white;
      font-family: Arial, sans-serif;
    }

    .sr-overlay-text {
      font-size: 2rem;
      text-align: center;
      animation: sr-fadeIn 1.5s ease-in-out infinite alternate;
    }

    @keyframes sr-fadeIn {
      0% { opacity: 0.3; }
      100% { opacity: 1; }
    }

    /* Styling the overlay text */
    .sr-overlay-text {
      padding: 20px;
      background-color: rgba(255, 255, 255, 0.2);
      border-radius: 10px;
    }

</style>
</head>
<body>
<div class="overlay"></div>

<div class="container">
  <h1 id="quizTitle">Quiz</h1>
  <div class="question">
    <p id="qType"></p>
    <p id="questionText"></p>
    <p><i id="weightageText"></i></p>
    <div>
         <button class="nonOptBtn" id="playClipBtn">Play Clip</button>
    </div>
    <p id="studentName"></p>
    <p id="teamText"></p>
    <div id="timer">00:00</div>
  </div>
  <div id="buttonContainer" class="buttons">

  <div id="optionBtnContainer"></div>
    <button class="nonOptBtn" id="pickCardBtn">Pick a card</button>
    <button class="nonOptBtn" id="correctBtn">Answered correctly</button>
    <button class="nonOptBtn" id="incorrectBtn">Couldn't answer correctly</button>
    <button class="nonOptBtn" id="partiallyCorrectBtn">Partially correct</button>
    <button class="nonOptBtn" id="pickAnotherBtn">Pick another student</button>
    <button class="nonOptBtn" id="pauseBtn">Pause countdown</button>
    <button class="nonOptBtn" id="showAnsBtn">Show answer</button>
    <button class="nonOptBtn" id="endBtn">End Quiz</button>
    <button id="scoresButton">Scores</button>

  </div>

<h4>Volume</h4>

<input type="range" min="1" max="100" class="slider" id="volumeRange">

  <footer id="footerText">Powered by Sourabh Suneja<br><br><span id="footerSpanText" style="font-size: 12px">Student selection is randomised with weighted probability method. The chance of a student getting selected again reduces as they get more and more chances to answer.</span></footer>
</div>




<div id="scoreTableContainer">
  <table id="scoreTable">
    <thead>
      <tr>
        <th>Participant</th>
        <th>Score</th>
        <th>Chances</th>
        <th id="lastTableCol">%</th>
      </tr>
    </thead>
    <tbody>
      <!-- Scores, chances, and percentage will be populated here dynamically using JavaScript -->
    </tbody>
  </table>
</div>


<div id="animation-container"></div>



<div id="mediaContainer">
  <div id="player"></div>
  <div class="closeButton" onclick="hideMediaContainer()">âœ–</div>
  <div id="audioText">Audio playing..</div>
</div>



<div id="startScreen">
 <div id="startScreenInner">
  <h1>Kwizee Go App</h1>
  <h3>Developed by Sourabh Suneja</h3>
  <p id="quizIntro">Loading...</p>
  <button id="startQuizBtn" style="visibility: hidden">Start Quiz</button>
 </div>
</div>


<div class="cm-modal-overlay" id="cmCustomModal">
    <div class="cm-modal-content">
        <h3>Enter your details to start the quiz:</h3>
        <input type="text" id="cmNameInput" placeholder="Your name...">
        <select id="cmGradeInput">
            <option value="" disabled selected>Select Grade</option>
            <option value="I">I</option>
            <option value="II">II</option>
            <option value="III">III</option>
            <option value="IV">IV</option>
            <option value="V">V</option>
            <option value="VI">VI</option>
            <option value="VII">VII</option>
            <option value="VIII">VIII</option>
            <option value="IX">IX</option>
            <option value="X">X</option>
            <option value="XI">XI</option>
            <option value="XII">XII</option>
        </select>
        <select id="cmSectionInput">
            <option value="" disabled selected>Select Section</option>
            <option value="A1">A1</option>
            <option value="A2">A2</option>
            <option value="A3">A3</option>
            <option value="A4">A4</option>
        </select>
        <button id="cmSubmitName">Submit</button>
    </div>
</div>



  <!-- Quiz Results Submission Waiting Overlay -->
  <div id="sr-loadingOverlay" class="sr-overlay">
    <div class="sr-overlay-text">Submitting Results. Wait...</div>
  </div>



<div id="card-picker">
<h1 id="nameInsideCardPicker"></h1>
<h2 id="cardPickHeading">Please pick a card</h2>
<p id="cardsIntro">The question's difficulty level is determined by the card you select. <br>Cards with higher weightages may offer more challenging questions but they also promise greater rewards. Please note that all cards have negative marking for wrong answers.</p>
<div class="carousel-container">
  <div class="carousel">
    <div class="carousel-item active" onclick="activateCard(0)" data-points="10">
      <h2>10 points</h2>
      <p>Reward:<br> +10 points for the correct answer</p>
      <p>Punishment:<br> -10 points for the wrong answer</p>
      <p class="cardQRemaining"></p>
    </div>
    <div class="carousel-item" onclick="activateCard(1)" data-points="25">
      <h2>25 points</h2>
      <p>Reward:<br> +25 points for the correct answer</p>
      <p>Punishment:<br> -25 points for the wrong answer</p>
      <p class="cardQRemaining"></p>
    </div>
    <div class="carousel-item" onclick="activateCard(2)" data-points="50">
      <h2>50 points</h2>
      <p>Reward:<br> +50 points for the correct answer</p>
      <p>Punishment:<br> -50 points for the wrong answer</p>
      <p class="cardQRemaining"></p>
    </div>
    <div class="carousel-item" onclick="activateCard(3)" data-points="75">
      <h2>75 points</h2>
      <p>Reward:<br> +75 points for the correct answer</p>
      <p>Punishment:<br> -75 points for the wrong answer</p>
      <p class="cardQRemaining"></p>
    </div>
    <div class="carousel-item" onclick="activateCard(4)" data-points="100">
      <h2>100 points</h2>
      <p>Reward:<br> +100 points for the correct answer</p>
      <p>Punishment:<br> -100 points for the wrong answer</p>
     <p class="cardQRemaining"></p>
    </div>
  </div>
</div>
<button id="selectCardBtn">Select this card</button>
<div id="card-picker-close-btn" onclick="closeCardPicker()">&times;</div>
</div>



<script>

// global variables
const sLink = "https://sourabhsuneja.github.io/quiz/";
const qbLink = "https://sourabhsuneja.github.io/question-paper/question-bank/";
let studentsFileName;
let questionsFileName;
let grade = '';
let section = '';
let quizType;
let allowMCQ;
let allowFillUp;
let allowTF;
let allowVSA;
let allowSA;
let allowLA;
let maxIndividualChances;
let forcedSelectionMethod;
let currentQuestionIndex;
let weightage = 1;
let cardWeightage = null;
let currentStudentIndex;
let scores;
let chances;
let teamScores;
let teamChances;
let countdownParam;
let countdownDuration;
let countdown;
let stopCountDown;
let countdownPaused = false;
let countdownPauseStateBeforeMedia = countdownPaused;
let maxChances;
let m;
let title;
let shuffle;
let qshuffle;
let customselect;
let absentStudents;
let maxChancesInput;
let currentUtterance;
let volume;
let slider;
let dataPickedFromCookie = false;
let correctAnsAvailable = null;
let ansExplanation = null;
let useteam;
let usecards;
let cardIndices;
let teammap;
let currentTeamIndex;
let studentShuffleMap = null;
let questionShuffleMap = null;
let player;
let timesMediaPlayed = [];
let timesPassed = 0;
let playFunction;
let qproceed;
let selectedCard = null;
let killPrevSession = 'n';
let quizID = '';


// global constants
const animationContainer = document.getElementById('animation-container');

const congratulatoryWords = [
    "Excellent job!",
    "Well done!",
    "Outstanding!",
    "Brilliant!",
    "Perfect!",
    "Bravo!",
    "You nailed it!",
    "Superb!",
    "Impressive!",
    "Terrific!",
    "Awesome!",
    "Great work!",
    "Phenomenal!",
    "Remarkable!",
    "Marvelous!",
    "Exceptional!",
    "Top-notch!",
    "Splendid!",
    "Magnificent!",
    "Fantastic!",
    "Spectacular!",
    "Stellar!",
    "Exceptional!",
    "Incredible!",
    "Remarkable!",
    "Amazing!",
    "Fabulous!",
    "Astounding!",
    "Ingenious!",
    "Exemplary!",
    "Astonishing!"
];

const encouragingWords = [
    "Nice try! Better luck next time!",
    "Don't give up!",
    "Learning is about trying!",
    "Mistakes help us grow!",
    "Every mistake is progress!",
    "Learning from mistakes is key!",
    "It's okay, keep going!",
    "You're learning with every try!",
    "Progress is made step by step!",
    "You're making strides!",
    "Learning is a journey!",
    "Every attempt counts!"
];
const partiallyCorrectWords = [
    "Close, keep going!",
    "Almost there!",
    "You're halfway there!",
    "You're making progress!",
    "You're getting closer!",
    "Not quite, but you're close!",
    "Getting closer, keep trying!"
];



// function to capitalise first letter of each word
function capitalizeEachWord(str) {
    // Convert the string to lowercase
    let lowercaseStr = str.toLowerCase();

    // Use a regular expression to match the first letter of each word and capitalize it
    let capitalizedStr = lowercaseStr.replace(/\b\w/g, function(char) {
        return char.toUpperCase();
    });

    return capitalizedStr;
}



// function to preload audio files
function preloadAudio() {
    const audio = new Audio();
    const video = new Audio();
    const image = new Audio();
    const correct = new Audio();
    const wrong = new Audio();
    const pop = new Audio();
    
    audio.src = './sounds/before-audio.mp3';
    video.src = './sounds/before-video.mp3';
    image.src = './sounds/before-image.mp3';
   correct.src = './sounds/correct.wav';
   wrong.src = './sounds/wrong.wav';
   pop.src = './sounds/pop.wav';

    // Preload the audio files
    audio.load();
    video.load();
    image.load();
    correct.load();
    wrong.load();
    pop.load();

    function playAudio(type) {
        switch (type) {
            case "correct":
                correct.play();
                break;
            case "wrong":
                wrong.play();
                break;
            case "pop":
                pop.play();
                break;
            case "audio":
                audio.play();
                break;
            case "video":
                video.play();
                break;
            case "image":
                image.play();
                break;
            default:
                console.error("Invalid type provided.");
        }
    }

    return playAudio;
}



// Function to delete the quiz cookie
function deleteQuizCookie() {
    document.cookie = "quizData=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
}



    // Function to create and display custom prompt dialog
    function customPrompt() {
        return new Promise((resolve) => {
            const modal = document.getElementById('cmCustomModal');
            const nameInput = document.getElementById('cmNameInput');
            const gradeInput = document.getElementById('cmGradeInput');
            const sectionInput = document.getElementById('cmSectionInput');
            const submitButton = document.getElementById('cmSubmitName');

            // Display the modal
            modal.style.display = 'block';

            // Focus on the input field when the modal is shown
            nameInput.focus();

            // Event listener for the submit button
            submitButton.addEventListener('click', function() {
                const name = nameInput.value.trim();
                const grade = gradeInput.value;
                const section = sectionInput.value;

                if (name && grade && section) {
                    // Hide the modal and resolve the promise with the entered name, grade, and section
                    modal.style.display = 'none';
                    resolve({ name, grade, section });
                } else {
                    alert('Please fill all fields.');
                }
            });
        });
    }




// function to intialize key quiz variables
function intializeQuizVariables() {


playFunction = preloadAudio();

 // parsing and using team map
 useteam = retrieveQuizData('useteam') ||  getParameterByName('useteam') || 'n';

 // parsing quizID
 quizID = retrieveQuizData('quizID') ||  getParameterByName('quizID') || '';

 // parsing grade
 grade = retrieveQuizData('grade') ||  getParameterByName('grade') || '';

 // parsing section
 section = retrieveQuizData('section') ||  getParameterByName('section') || '';

// check whether force kill previous sessions is set to 'y'
killPrevSession = retrieveQuizData('killPrevSession') || 'n';

teammap = retrieveQuizData('teammap') ||  getParameterByName('teammap') || null;

// variable to track team turns
currentTeamIndex = 0;

if(typeof teammap === 'string') {
    teammap = parseTeamMap(teammap);
}



 // Array to store absent students
  absentStudents = retrieveQuizData('absent') ||  getParameterByName('absent') || [];

// parse absentStudents into an array if it is a string retrieved from the URL

if (typeof absentStudents === "string") {
  try {
    let parsedArray = JSON.parse(absentStudents);
    if (Array.isArray(parsedArray)) {
      absentStudents = parsedArray;
    } else {
      console.error("The parsed value is not an array.");
    }
  } catch (error) {
    console.error("Error parsing the string:", error);
  }
}


// remove absent students from the students array

if (Array.isArray(absentStudents) && absentStudents.length > 0) {

    // sort the students array before removing absentees
    students.sort();

    // Sort the absentStudents array in descending order
    absentStudents.sort((a, b) => b - a);

    // Remove absent students from the students array
    absentStudents.forEach(index => {
        students.splice(index, 1);
    });

}



  // Index to keep track of current question
  currentQuestionIndex = parseInt(retrieveQuizData("currentQuestionIndex")) || 0;

// Arrays to store scores & chances
  scores = retrieveQuizData('scores') || {};
  chances = retrieveQuizData('chances') || {};


teamScores = retrieveQuizData('teamScores') || {};
teamChances = retrieveQuizData('teamChances') || {};



// Ask the user for the maximum chances
maxChancesInput = maxIndividualChances || retrieveQuizData('maxChances') ||  getParameterByName('maxchances') ||  prompt("How many maximum chances do you want to give to each student? (Defaults to 3)");
// Convert the input to a number
maxChances = parseInt(maxChancesInput);

// Check if the input is a valid number
if (isNaN(maxChances) || maxChances <= 0) {
    // If not a valid number, set default value to 3
    maxChances = 3;
}

// Initialize countdown variable based on parameter or user input
countdownParam = parseInt(retrieveQuizData('countdownDuration')) || parseInt(getParameterByName("countdown"));

  if (typeof countdownParam === 'number' && !isNaN(countdownParam) && countdownParam >= 0) {
    countdownDuration = countdownParam;
  } else {
    var userInput = prompt("Specify the countdown duration in seconds for the quiz. After this duration, another student will be prompted to answer the same question. If you prefer not to have a countdown, simply leave this field blank.");
    countdownDuration = userInput ? parseInt(userInput) : 0;
  }

countdown = countdownDuration; // Initial countdown value in seconds
stopCountDown; // Flag variable to start/stop countdown

if(!countdown) {
    stopCountDown = true;
    document.getElementById('timer').style.display = 'none';
    
} else {
    stopCountDown = false;
}

startCountdown();


// code to handle utterances

currentUtterance; // Variable to store the current speaking utterance
initialVolume = parseInt(getParameterByName ('volume')) || 50 // Initial volume value

// code to handle the volume slider

  slider.value = initialVolume;

// other parameters

customselect = retrieveQuizData("customselect") || getParameterByName('customselect');
m = forcedSelectionMethod || retrieveQuizData("m") || getParameterByName('m');
title = retrieveQuizData("title") || getParameterByName('title');
shuffle = retrieveQuizData("shuffle") ||  getParameterByName('shuffle');
qshuffle = retrieveQuizData("qshuffle") ||  getParameterByName('qshuffle') || 'n';
qproceed = retrieveQuizData("qproceed") ||  getParameterByName('qproceed') || 'auto';
studentShuffleMap = retrieveQuizData("studentShuffleMap") || null;
questionShuffleMap = retrieveQuizData("questionShuffleMap") || null;
currentStudentIndex = retrieveQuizData("currentStudentIndex") || 0;
usecards = getParameterByName('usecards') || 'n';

// get allowed qTypes
allowMCQ = retrieveQuizData("allowMCQ") ||  getParameterByName('allowMCQ') || 'n';
allowFillUp = retrieveQuizData("allowFillUp") ||  getParameterByName('allowFillUp') || 'n';
allowTF = retrieveQuizData("allowTF") ||  getParameterByName('allowTF') || 'n';
allowVSA = retrieveQuizData("allowVSA") ||  getParameterByName("allowVSA") || 'n';
allowSA = retrieveQuizData("allowSA") ||  getParameterByName("allowSA") || 'n';
allowLA = retrieveQuizData("allowLA") ||  getParameterByName("allowLA") || 'n';

// keep only allowed qTypes in questions
   filterQuestions();

// if cards are used, extract card indices and values

if(usecards == 'y') {
   cardIndices = extractCardIndices();
   document.getElementById('lastTableCol').innerText = 'Efficiency';
}


}




// Asynchronous function to check quiz cookie and prompt user
async function checkQuizCookie() {
    return new Promise((resolve) => {
        var cookieData = document.cookie.split(';').find(cookie => cookie.trim().startsWith('quizData='));

        if (cookieData) {

            // if cards are being used or killPrevSession is set to 'y', drop the cookies as resume support is not available with card plays

if(getParameterByName('usecards') == 'y' || getParameterByName('killPrevSession') == 'y') {
                 deleteQuizCookie();
                 resolve(false);
                 return;
            } 
            // Prompt the user with a dialog box
            var pickUp = confirm("The previous quiz session didn't complete properly. Do you want to pick up from where you left off?");
            if(!pickUp) {
               deleteQuizCookie();
            } else {
               dataPickedFromCookie = true;
            }
            resolve(pickUp);
        } else {
            // If cookie is not present, resolve to false
            resolve(false);
        }
    });
}







// Function to store key values as cookies so that the quiz can be picked from where we left off in case of unexpected failure
function storeQuizData(currentStudent) {
    // Define key values to be stored
    var dataToStore = {
        currentQuestionIndex: currentQuestionIndex,
        scores: scores,
        chances: chances,
        studentsFileName: studentsFileName,
        questionsFileName: questionsFileName,
        currentStudent: currentStudent,
        currentStudentIndex: currentStudentIndex,
        countdownDuration: countdownDuration,
        maxChances: maxChances,
        m: m,
        title: title,
        shuffle: shuffle,
        qshuffle: qshuffle,
        customselect: customselect,
        useteam: useteam,
        teammap: teammap,
        studentShuffleMap: studentShuffleMap,
        questionShuffleMap: questionShuffleMap,
        quizType: quizType,
        qproceed: qproceed,
        allowMCQ: allowMCQ,
        allowFillUp: allowFillUp,
        allowTF: allowTF,
        allowVSA: allowVSA,
        allowSA: allowSA,
        allowLA: allowLA,
        grade: grade,
        section: section,
        quizID: quizID
    };

    // Store data as a cookie
    // Set cookie with expiration date one year from now
    var expiryDate = new Date();
    expiryDate.setFullYear(expiryDate.getFullYear() + 1);
    document.cookie = "quizData=" + JSON.stringify(dataToStore) + "; expires=" + expiryDate.toUTCString() + "; path=/;";

}


// Function to retrieve a specific value from stored cookie data based on key
function retrieveQuizData(key) {
    var cookieData = document.cookie.split(';').find(cookie => cookie.trim().startsWith('quizData='));

    if (cookieData) {
        // Extract and parse stored data
        var storedData = JSON.parse(cookieData.split('=')[1]);

        // Return value corresponding to the provided key
        return storedData[key];
    } else {
        // Return null if no stored data found
        return null;
    }
}




// function to parse teammap
function parseTeamMap(teammap) {
    try {
        const parsedObject = JSON.parse(teammap);
        if (parsedObject && typeof parsedObject === 'object' && Object.keys(parsedObject).length > 0) {
            return parsedObject;
        } else {
            return null;
        }
    } catch (error) {
        return null;
    }
}



// function to consolidate scores and chances in case team maps are available
function consolidateScoresAndChances() {
    for (let team in teammap) {
        let teamScore = 0;
        let teamChance = 0;
        for (let i = 0; i < teammap[team].length; i++) {
            let studentIndex = teammap[team][i];
            let studentName = students[studentIndex];
            // Check if the student is in scores and chances objects
            if (scores.hasOwnProperty(studentName)) {
                teamScore += scores[studentName];
            }
            if (chances.hasOwnProperty(studentName)) {
                teamChance += chances[studentName];
            }
        }
        teamScores[team] = teamScore;
        teamChances[team] = teamChance;
    }
}





function displayTeamScoresAndChances() {

    // return back if team map is not available
     if(useteam != 'y' || !teammap) {
           return;
     }
    // First, consolidate the scores and chances
    consolidateScoresAndChances();

    // Get the container element
    let container = document.getElementById('scoreTableContainer');

    // Remove any existing heading with the same id
    let existingHeading = document.getElementById('teamScoresHeading');
    if (existingHeading) {
        existingHeading.remove();
    }

    // Create a heading for the table
    let heading = document.createElement('h2');
    heading.textContent = 'Team-wise Scores';
    heading.id = 'teamScoresHeading'; // Assign unique id to the heading
    heading.style.textAlign = 'center';
    container.appendChild(heading);

    // Remove any existing table with the same id
    let existingTable = document.getElementById('teamScoresTable');
    if (existingTable) {
        existingTable.remove();
    }

    // Create a table element
    let table = document.createElement('table');
    table.id = 'teamScoresTable'; // Assign id to the table

    // Create table header
    let thead = document.createElement('thead');
    let headerRow = thead.insertRow();
    let headers = ['Team', 'Score', 'Chances', '%'];
    if(usecards == 'y') {
        headers[3] = 'Efficiency';
    }
    for (let header of headers) {
        let th = document.createElement('th');
        th.textContent = header;
        headerRow.appendChild(th);
    }
    table.appendChild(thead);

    // Create table body
    let tbody = document.createElement('tbody');

    // Sort teams by percentage (descending order)
    let sortedTeams = Object.keys(teamScores).sort((a, b) => {
        return (teamScores[b] / teamChances[b]) - (teamScores[a] / teamChances[a]);
    });

    // Create rows for each team
    sortedTeams.forEach(team => {
        let row = tbody.insertRow();
        let score = teamScores[team];
        let chance = teamChances[team];
        let percentage = ((score / chance) * 100).toFixed(2);
        if(usecards == 'y') {
             percentage = ((score / chance)).toFixed(2);
        }
        percentage = isNaN(percentage) ? '-' : percentage;
        [team, score, chance, percentage].forEach(value => {
            let cell = row.insertCell();
            cell.textContent = value;
        });
    });
    table.appendChild(tbody);

    // Append the table to the container
    container.appendChild(table);
}






// Function to calculate team-wise percentage and display chart
  function displayTeamChart() {

        // return back if team map is not available
     if(useteam != 'y' || !teammap) {
           return;
     }

    var chartContainer = document.createElement('div');
    chartContainer.classList.add('chart-container');

    var teamData = [];

    // Calculate percentages and store team data
    for (var team in teamScores) {
      var percentage = (teamScores[team] / teamChances[team]) * 100;
      if(usecards == 'y') {
           percentage = (teamScores[team] / teamChances[team]).toFixed(2);
      }
      teamData.push({ name: team, percentage: percentage });
    }

    // Sort teams based on their percentages (highest to lowest)
    teamData.sort(function(a, b) {
      return b.percentage - a.percentage;
    });

    // Create bars for each team
    teamData.forEach(function(team) {
      var bar = document.createElement('div');
      var shade = Math.round(205 - (team.percentage * 1.55)); // Calculate shade of green
      shade = Math.max(shade, 50); // Ensure a minimum value for visibility
      bar.style.backgroundColor = 'rgb(0,' + '120' + ',0)'; // Set background color
      bar.classList.add('bar');
      bar.style.width = (team.percentage < 0 ? 0 : team.percentage) + '%';
      
      // Create span for text and percentage
      var barText = document.createElement('span');
      barText.classList.add('bar-text');
      barText.textContent = team.name + ': ' + parseFloat(team.percentage).toFixed(2);

      if(usecards != 'y') {
            barText.textContent += '%';
      }

      bar.appendChild(barText);
      
      chartContainer.appendChild(bar);
    });

    document.body.appendChild(chartContainer);

// create download teamScoresheet button
// Create a button element
var button = document.createElement("button");
// Set button text
button.innerHTML = "Download Team Score Sheet";
// Set button id
button.id = "downloadTeamScoreBtn";
// Center align the button
button.style.display = "block";
button.style.margin = "auto";

// Append the button to the end of the page body
document.body.appendChild(button);
// Attach click event handler to the button
document.getElementById("downloadTeamScoreBtn").addEventListener("click",function() {
      downloadCSV(true);
});

  }





// function to remove keys like 'no one' or 'nobody' from scores and chances just in case they got inserted
function removeKeysWithNobodyOrNoOne() {
    for (let key in scores) {
        if (key.toLowerCase().includes('nobody') || key.toLowerCase().includes('no one')) {
            delete scores[key];
        }
    }
    
    for (let key in chances) {
        if (key.toLowerCase().includes('nobody') || key.toLowerCase().includes('no one')) {
            delete chances[key];
        }
    }
}







  // Function to get URL parameters
function getParameterByName(name, url) {
    if (!url) url = window.location.href;
    name = name.replace(/[[\]]/g, '\\$&');
    var regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)'),
        results = regex.exec(url);
    if (!results) return null;
    if (!results[2]) return '';
    return decodeURIComponent(results[2].replace(/\+/g, ' '));
}





  // Function to shuffle array on the basis of provided shuffle map or with Fisher-Yates method
  function shuffleWithMap(originalArray, providedShuffleMap = null) {
    // Create a copy of the original array to avoid modifying the original array
    const array = originalArray.slice();

    // Initialize shuffle map array
    let shuffleMap = [];

    if (providedShuffleMap) {
        // Use the provided shuffle map to shuffle elements
        shuffleMap = providedShuffleMap.slice();
        const shuffledArray = [];
        for (let i = 0; i < array.length; i++) {
            shuffledArray[shuffleMap[i]] = array[i];
        }

        return {
            shuffledArray: shuffledArray,
            shuffleMap: shuffleMap
        };
    } else {
        // Fisher-Yates shuffle algorithm
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]]; // Swap elements

        }
        // create shuffle map
        originalArray.forEach(function (item) {
        	shuffleMap.push(array.indexOf(item));
        });

        return {
            shuffledArray: array,
            shuffleMap: shuffleMap
        };
    }
}



// function to filter out non-supported or disallowed qTypes
function filterQuestions() {

  let supported = ['MCQ', 'Fill up', 'True/False', 'Very Short Answer Type', 'Short Answer Type', 'Long Answer Type'];

  let selected = [];

  if(allowMCQ !== 'y') {
    supported[0] = null;
  }
  if(allowFillUp !== 'y') {
    supported[1] = null;
  }
  if(allowTF !== 'y') {
    supported[2] = null;
  }
  if(allowVSA !== 'y') {
    supported[3] = null;
  }
  if(allowSA !== 'y') {
    supported[4] = null;
  }
  if(allowLA !== 'y') {
    supported[5] = null;
  }

  window.questions.forEach((question, index) => {
    let JSONPart = extractJSONFromString(question); 
    let qPart = extractStringBeforeJSON(question);
    let qType = JSONPart['qType'];

    // if True/False type, transform it into MCQ so that "True" and "False" option buttons can be shown
    if(qType === 'True/False' && supported.includes(qType)) {
        let ans = "False";
        if(!qPart.endsWith('.')) {
             qPart += ".";
        }
        qPart += " Is it true or false?" ;
        if(JSONPart['ansExplanation'].toLowerCase() === 't' || JSONPart['ansExplanation'].toLowerCase() === 'true') {
            ans = "True";
        }
        JSONPart['ansExplanation'] = "";
        let transformed = qPart + '(Options: Option A} True Option B} False Correct: ' + ans + ')JSONParams:' + JSON.stringify(JSONPart);

        selected.push(transformed);

    }
 
    if(supported.includes(qType) && qType !== 'True/False') {
        selected.push(question);
    }
    
  });
  // forEach ends
  window.questions = selected;
}
// function ends



 // Function to initialize quiz
  async function initializeQuiz() {
  try {

     // pause countdown until the quiz starts
    countdownPaused = true;

     let studentsData;

    // wait till the presence of cookies is checked
    let useCookie = await checkQuizCookie();
    
  // determine quiz type
   quizType = retrieveQuizData("quizType") || getParameterByName('quizType') || 'group';
   

   // if user wants to pick up from where the quiz was left off
    if(useCookie) {
         studentsFileName = retrieveQuizData('studentsFileName');
         questionsFileName = retrieveQuizData('questionsFileName');
    } else {
         // Attempt to retrieve file names from URL parameters
studentsFileName = getParameterByName('s');
questionsFileName =  getParameterByName('q');
    }



// If URL parameters are not available, prompt the user for file names
if (!studentsFileName) {

   if(quizType == "group") {
       studentsFileName = prompt("Enter the file name for students data (e.g., students.txt):").trim();
   } else {
       let studentInfo = await customPrompt();
       studentsFileName = studentInfo.name.trim();
       grade = studentInfo.grade;
       section = studentInfo.section;
   }

}


if (!questionsFileName) {
    questionsFileName = prompt("Enter the file name for questions data (e.g., questions.txt):").trim();
}
    
    // Add .txt extension if not already provided by the user
    if (!studentsFileName.endsWith('.txt') && quizType == "group") {
      studentsFileName += '.txt';
    }
    if (!questionsFileName.endsWith('.txt')) {
      questionsFileName += '.txt';
    }

    if (!studentsFileName || !questionsFileName) {
      throw new Error("Invalid file names");
    }
    const questionsData = await fetchMultipleFilesData(questionsFileName, "questions");
    window.questions = questionsData;
    if(quizType == 'group') {
         studentsData = await fetchMultipleFilesData(studentsFileName, "students");
    }
    else {
    if (studentsFileName.includes(',')) {
        studentsData = studentsFileName.split(',').map(item => item.trim());
    } else {
        studentsData = [studentsFileName];
        document.getElementById('pickAnotherBtn').style.display = 'none';
    }
    maxIndividualChances = 9999999;
    forcedSelectionMethod = 'rotation';
}
    // capitalize first letter of each student name
    window.students = studentsData.map(capitalizeEachWord);

    // intialize all quiz variables
   intializeQuizVariables();

   
    // add quiz intro to the start screen
    document.getElementById('quizIntro').innerText = 'You are about to start the quiz with ' + students.length + ' ' + (students.length === 1 ? 'participant' : 'participants') + ' and ' + questions.length + ' ' + (questions.length === 1 ? 'question' : 'questions') + '.';
   // make the start quiz button visible
  document.getElementById('startQuizBtn').style.visibility = "visible";
   // attach event listener to start quiz button
    document.getElementById('startQuizBtn').addEventListener("click", function() {
    document.getElementById('startScreen').style.display = 'none';
    // resume countdown, if exists
    countdownPaused = false;
    startQuiz();
});

  } catch (error) {
    console.error(error.message);
  }

}


  
// function to take one or more filenames and return a consolidated array of data fetched from each file using fetchData function

async function fetchMultipleFilesData (fileNames, kind) {
  const files = fileNames.split('+');
  const consolidatedData = [];
  for (const fileName of files) {
    try {
      const f = fileName.endsWith('.txt') ? (fileName) : (fileName + '.txt') ;
      const data = await fetchData(f, kind);
      consolidatedData.push(...data);
    } catch (error) {
      console.error(`Error fetching data from ${fileName}:`, error);
    }
  }
  
  return consolidatedData;
}





  // Function to fetch data from a file using AJAX and return a promise
  function fetchData(fileName, kind) {
    if(kind === "students") {
      fileName = sLink + fileName;
    }
    else if(kind === "questions") {
      fileName = qbLink + fileName;
    }
    return new Promise((resolve, reject) => {
      const xhr = new XMLHttpRequest();
      xhr.onreadystatechange = function() {
        if (xhr.readyState === XMLHttpRequest.DONE) {
          if (xhr.status === 200) {
            const data = xhr.responseText.split('\n').map(item => item.trim()).filter(item => item !== '');
            resolve(data);
          } else {
            reject(new Error("Failed to load data"));
          }
        }
      };
      xhr.open("GET", fileName, true);
      xhr.send();
    });
  }

  // Function to start the quiz after questions and students are loaded
  function startQuiz() {
    

    // change footer text in case of rotational selection and when teaming is not done
    if(m == 'rotation' && useteam != 'y') {
       document.getElementById("footerSpanText").textContent = 'Student selection is done on a rotational basis. Students will get a chance to answer one after another in the pre-decided order.';
    }
    
    if(m == 'rotation' && useteam == 'y') {
       document.getElementById("footerSpanText").textContent += " Although you've selected the rotation method, random selection is still enforced when picking students from each team. However, all teams get their turns on a rotational basis.";
    }


    // shuffle student names if shuffle parameter is set to 'y' or sort alphabetically if set to az or za
if(shuffle == 'y') {
	
const obj = shuffleWithMap(window.students, studentShuffleMap)
     window.students = obj['shuffledArray'];
     studentShuffleMap = obj['shuffleMap']
 document.getElementById("footerSpanText").textContent += ' The names have been shuffled using Fisher-Yates algorithm.';
 
}
else if(shuffle == 'az' || useteam == 'y') {
     window.students.sort();
     document.getElementById("footerSpanText").textContent += ' The names have been alphabetically sorted A-Z.';
}
else if(shuffle == 'za') {
     window.students.sort((a, b) => b.localeCompare(a));
     document.getElementById("footerSpanText").textContent += ' The names have been alphabetically sorted Z-A.';
}


// shuffle questions if qshuffle parameter is set to 'y' and cards are not being used
if(qshuffle == 'y' && usecards != 'y') {
	
const obj = shuffleWithMap(window.questions, questionShuffleMap)
     window.questions = obj['shuffledArray'];
     questionShuffleMap = obj['shuffleMap']
 document.getElementById("footerSpanText").textContent += ' The questions have been shuffled using Fisher-Yates algorithm.';
 
}
    
    // add event listeners to all buttons
    document.getElementById("pickCardBtn").addEventListener("click", openCardPicker);
    document.getElementById("correctBtn").addEventListener("click", answeredCorrectly);
    document.getElementById("incorrectBtn").addEventListener("click", answeredIncorrectly);

document.getElementById("partiallyCorrectBtn").addEventListener("click", answeredPartiallyCorrectly);
    document.getElementById("pickAnotherBtn").addEventListener("click", pickAnotherStudent);

document.getElementById("pauseBtn").addEventListener("click", pauseCountdown);

document.getElementById("showAnsBtn").addEventListener("click", showAnswer);

document.getElementById("endBtn").addEventListener("click", displayScores);

document.getElementById("quizTitle").textContent = title || 'Quiz';

// create custom select box if custom selection is allowed
    if(customselect == 'y') {
         attachCustomSelect();
    }

displayQuestion();

// if countdown is not set, do not show the pause countdown button
if(!countdownDuration) {
   document.getElementById("pauseBtn").style.display = 'none';
}

// if cards are not enabled, do not show the card pick button
if(usecards != 'y') {
   document.getElementById("pickCardBtn").style.display = 'none';
}


  }

  
    // Function to display question and student name

  async function displayQuestion(pass = false, isFirst = true) {
    if (!window.students || !window.questions) {
      console.log("Students or questions data not loaded.");
      return;
    }

    // enable all non-option buttons after animation
    const nonOptBtns = document.querySelectorAll('.nonOptBtn');
    nonOptBtns.forEach(function(button) {
    button.disabled = false;
    });

  
// if it is not a passed question, set selectedCard to null and also show the select card button. Also set the card selection state to waiting
if(!pass && usecards == 'y') {
    selectedCard = null;
    document.getElementById("pickCardBtn").style.display = 'block';
    
}

// get required DOM elements
const playClipBtn = document.getElementById("playClipBtn");

const questionText = document.getElementById("questionText");

const qType = document.getElementById("qType");

const studentName = document.getElementById("studentName");

const nameInsideCardPicker = document.getElementById('nameInsideCardPicker');

const buttonsDiv = document.getElementById('optionBtnContainer');

const correctBtn = document.getElementById('correctBtn');

const incorrectBtn = document.getElementById('incorrectBtn');

const partiallyCorrectBtn = document.getElementById('partiallyCorrectBtn');

const showAnsBtn = document.getElementById('showAnsBtn');



if( (!pass && usecards == 'y') || (usecards == 'y' && pass && selectedCard == null) ) {

// display text: question will be shown after a card is picked
questionText.innerText = "Question will be shown after you pick a card";

// display text: question weightage will be shown later
document.getElementById('weightageText').innerText = '(question weightage will depend on the card chosen)';

// hide play Clip button
playClipBtn.style.display = "none";

// hide option buttons
buttonsDiv.style.display = 'none';

// hide show answer button
showAnsBtn.style.display = 'none';

   if(pass) {
     speakUp("Question passed", 0.8);
   } else {
     speakUp("Please pick a card", 0.8);
   }

}


// student selection starts
    
    let randomStudent; 
    
    if(dataPickedFromCookie) {
    randomStudent = retrieveQuizData('currentStudent');
    dataPickedFromCookie = false;

}  

else if(useteam === 'y' && teammap) {
              randomStudent  = pickRandomStudentFromTeam();
     }


else {

let selectionMode = m || 'random';
    if(selectionMode == 'random') {
            randomStudent = pickRandomStudent();
   } else if(selectionMode == 'rotation') {
            randomStudent = getNextStudent();
  }
     else {
            randomStudent = pickRandomStudent();
     }

}


    studentName.textContent = "Question for " + randomStudent.trim();
    nameInsideCardPicker.textContent = randomStudent.trim();

     // reset countdown
     resetCountdown();


// student selection ends

// update quiz cookies after student selection
saveSession(randomStudent.trim());


// return back in case question has been passed and usecards is set to 'y'

if(usecards == 'y' && pass) {
   speakUp("Question passed", 0.8);
   return;
}


// temporarily hide correct, incorrect, partially correct and show answer buttons
  correctBtn.style.display = 'none';
  incorrectBtn.style.display = 'none';
  partiallyCorrectBtn.style.display = 'none';
 showAnsBtn.style.display = 'none';


// fetch a card if usecards is set to 'y' and card has not been chosen

if(usecards == 'y' && selectedCard == null) {

  // set card weightage to null until a card is picked
     cardWeightage = null;

 // temporarily pause countdown while waiting for the student to pick a card
     let countdownStateBeforeCardPick = countdownPaused;
     countdownPaused = true;


     selectedCard = await selectCard();
         let newQuestionIndex = getRandomItemAndRemove(selectedCard);
         currentQuestionIndex = newQuestionIndex;
        
      

     // update quiz cookies after card selection and question pickup

saveSession(randomStudent.trim());



     
     // hide the card select button once a card has been chosen
    document.getElementById("pickCardBtn").style.display = 'none';

// bring countdown back to the prior state
    countdownPaused = countdownStateBeforeCardPick;

}


    // handling the question
      
    const question = extractStringBeforeJSON(window.questions[currentQuestionIndex].trim());
    const params = extractJSONFromString(window.questions[currentQuestionIndex].trim()); 

  // reset question weightage to 1
    weightage = 1;
  // reset ansExplanation to null
    ansExplanation = null;
    
   if(!handleMCQ(question)) {
   questionText.innerHTML = question;

  
// Show the buttons
  correctBtn.style.display = 'block';
  incorrectBtn.style.display = 'block';
  partiallyCorrectBtn.style.display = 'block';

}

// display question type
qType.textContent = params['qType'];

// show 'show answer' button
showAnsBtn.style.display = 'block';

if(!pass) {
timesMediaPlayed[currentQuestionIndex] = 0;
timesPassed = 0;
} else {
timesPassed++;
}

// if params available

if(params) {

// set question weightage
weightage = params['weightage'] || 1;

// store explanation for correct answer, if available
if(params['ansExplanation']) {
  ansExplanation = params['ansExplanation'];
}

// if JSON params contain embedded media
if(params['mediaEmbedded'] == 'audio' || params['mediaEmbedded'] == 'video' || params['mediaEmbedded'] == 'image') {
    playClipBtn.style.display = "inline-block";
    buttonsDiv.style.display = 'none';
    showAnsBtn.style.display = 'none';
    playClipBtn.onclick = function() {

// pause countdown
    countdownPaused = true;

// Cancel previous speech synthesis if there is an ongoing utterance
    if (currentUtterance) {
        speechSynthesis.cancel();
    }

playFunction(params['mediaEmbedded']);


 setTimeout(function() {
    playMedia(params['mediaEmbedded'], params['mediaLink'], params['startTime'], params['endTime']);
}, 3500);



   };

} else {
   playClipBtn.style.display = "none";
   buttonsDiv.style.display = "block";
}

// if audio
if(params['mediaEmbedded'] == 'audio') {
    playClipBtn.innerText = "Play audio";
}
// else if video
else if(params['mediaEmbedded'] == 'video') {
    playClipBtn.innerText = "Play video";
}
// else if image
else if(params['mediaEmbedded'] == 'image') {
    playClipBtn.innerText = "Show image";
}

    
} else {
// if params not available or invalid JSON
    playClipBtn.style.display = "none";
    buttonsDiv.style.display = "block";
}


// if question is a passed one, and the media has been played at least once, do not hide the options and show answer button in case of media based questions 

if(pass && timesMediaPlayed[currentQuestionIndex] >= 1) {
   buttonsDiv.style.display = "block";
   showAnsBtn.style.display = 'block';
}


// display question weightage or card weightage

if(usecards != 'y') {
document.getElementById('weightageText').innerText = '(question carries ' + weightage + (weightage > 1 ? ' points' : ' point') + ')';
} else {
document.getElementById('weightageText').innerText = '(question carries ' + cardWeightage + (cardWeightage > 1 ? ' points' : ' point') + ')';
}


saveSession(randomStudent.trim());
 
    if(!pass) {
        if(isFirst) {
          speakUp("Let's start with our first question: " + questionText.textContent, 0.8);
        } else {
          speakUp("Next question: " + questionText.textContent, 0.8);
        } 
}
else {
    speakUp("Question passed", 0.8);
}

  }


  // function to get next student in case of rotational selection
  
function getNextStudent() {
    const student = window.students[currentStudentIndex]; // get the student at the current index
    currentStudentIndex = (currentStudentIndex + 1) % window.students.length; // move to the next index, looping back to 0 if end is reached

    // if selected student has no chances left, keep looping forward until you find a student with chamces left or reach the end
   
    if(maxChances - (chances[student] || 0) > 0) {
    	return student; // return the current student
    } else {
    	let start = currentStudentIndex;
    	for(let i = start; i<students.length; i++) {
    		if(maxChances - (chances[students[i]] || 0) > 0) {
    			return students[i]
    		}
    	}
    	// if end has been reached, start over from index 0 and continue until just the previous student
    	for(let i = 0; i<(currentStudentIndex-1); i++) {
    		if(maxChances - (chances[students[i]] || 0) > 0) {
    			return students[i]
    		}
    	}
    	return 'no one (all students have exhausted their chances). Click on "End Quiz" to display scores.';
    }  
}


  


// Function to pick a random student with reduced chances as they answer more questions
function pickRandomStudent() {
    let weightedStudents = [];
    
    // Populate the array with students based on their chances
    for (let student of window.students) {
        for (let i = 0; i < maxChances - (chances[student] || 0); i++) {
            weightedStudents.push(student);
        }
    }

    // Select a random student from the weighted array
    let randomIndex;
    let randomStudent;
   
        randomIndex = Math.floor(Math.random() * weightedStudents.length);
        randomStudent = weightedStudents[randomIndex];
    
     
    return randomStudent || 'no one (all students have exhausted their chances). Click on "End Quiz" to display scores.';
}




function pickRandomStudentFromTeam() {

    // container for showing the currently chosen team name
    const teamName = document.getElementById('teamText');

    // Initialize team order
    const teams = Object.keys(teammap);

    // Get students for the current team
    const currentTeam = teammap[teams[currentTeamIndex]];
    const currentTeamName = teams[currentTeamIndex];

   // set current team name
       teamName.innerText = '(Team: ' + currentTeamName + ')';

    // Create weighted array of students based on remaining chances
    let weightedArray = [];
    currentTeam.forEach(studentIndex => {
        const student = students[studentIndex];
        const chancesLeft = maxChances - (chances[student] || 0);
        for (let i = 0; i < chancesLeft; i++) {
            weightedArray.push(student);
        }
    });

    // Pick a random student from the weighted array
    const randomIndex = Math.floor(Math.random() * weightedArray.length);
    const randomStudent = weightedArray[randomIndex];


    // Update current team index for next call
    currentTeamIndex = (currentTeamIndex + 1) % teams.length;

    return randomStudent || ('no one (all students from the current team [' + currentTeamName + '] have exhausted their chances). Click on "End Quiz" to display scores or pick another student to move to the next team.') ;
}






// Function to display correct answer and proceed to next question
  function showAnswer() {
    playFunction('pop');
    showAnswerAnimation();
    var text = document.getElementById('studentName').textContent;

var index = text.indexOf('for');

const currentStudent = text.substring(index + 4);


    if (chances[currentStudent] === undefined) {
      chances[currentStudent] = 1;
    } else {
      chances[currentStudent]++;
    }
    nextQuestion();
  }


  // Function to handle correct answer
  function answeredCorrectly() {
    playFunction('correct');
    showAnimation(true);
    var text = document.getElementById('studentName').textContent;

var index = text.indexOf('for');

const currentStudent = text.substring(index + 4);


    if (scores[currentStudent] === undefined) {
      scores[currentStudent] = (cardWeightage || weightage);
    } else {
      scores[currentStudent] += (cardWeightage || weightage);
    }

if (chances[currentStudent] === undefined) {
      chances[currentStudent] = 1;
    } else {
      chances[currentStudent]++;
    }


    nextQuestion();
  }

  // Function to handle partially correct answer
  function answeredPartiallyCorrectly() {
    playFunction('correct');
    showAnimation(0.5);
    var text = document.getElementById('studentName').textContent;

var index = text.indexOf('for');

const currentStudent = text.substring(index + 4);


    if (scores[currentStudent] === undefined) {
      scores[currentStudent] = ((cardWeightage || weightage)/2);
    } else {
      scores[currentStudent] += ((cardWeightage || weightage)/2);
    }

if (chances[currentStudent] === undefined) {
      chances[currentStudent] = 1;
    } else {
      chances[currentStudent]++;
    }


    nextQuestion();
  }

  // Function to handle incorrect answer
  function answeredIncorrectly() {
    playFunction('wrong');
    showAnimation(false);
    var text = document.getElementById('studentName').textContent;

var index = text.indexOf('for');

const currentStudent = text.substring(index + 4);

// deduct points in case cards are being used
if(usecards == 'y') {
    if (scores[currentStudent] === undefined) {
      scores[currentStudent] = (cardWeightage * -1);
    } else {
      scores[currentStudent] -= cardWeightage;
    }
}


    if (chances[currentStudent] === undefined) {
      chances[currentStudent] = 1;
    } else {
      chances[currentStudent]++;
    }
    nextQuestion();
  }

  // Function to pick another student
  function pickAnotherStudent() {
   
var text = document.getElementById('studentName').textContent;

var index = text.indexOf('for');

const currentStudent = text.substring(index + 4);


    if (chances[currentStudent] === undefined) {
      chances[currentStudent] = 1;
    } else {
      chances[currentStudent]++;
    }

    displayQuestion(true, false);
  }

  // Function to move to the next question
  function nextQuestion(oneParticipant = false) {
    currentQuestionIndex++;
    
    // delay until the animations complete
   let currentPauseState = countdownPaused;
   countdownPaused = true;
   countdown++;

   // proceed only when a click is done anywhere on the screen
   waitForClick().then(() => {

   countdownPaused = currentPauseState;

   // hide animation container
   document.getElementById('animation-container').style.display = 'none';

    if ( (usecards != 'y' && currentQuestionIndex < window.questions.length) || (usecards == 'y' && Object.keys(cardIndices).length > 0) ) {
      document.getElementById("qType").textContent = "";
      displayQuestion(false, false);
    } else {
      displayScores();
    }

});


// programmatically click the document body after a negligible delay to move to the next question automatically in case of one participant quiz when it's timed out
if(oneParticipant) {
   setTimeout(() => {
  triggerClick();
}, 10);

}

// programmatically click the document body after 3 seconds to move to the next question automatically in case qproceed method is auto
if(qproceed === 'auto') {
   setTimeout(() => {
  triggerClick();
}, 3000);

}


    
  }

  // Function to display scores
  function displayScores() {

removeKeysWithNobodyOrNoOne();

// re-consolidate team scores
consolidateScoresAndChances();

// store current session data for long term retrieval
storeQuizSession();

// delete short term cookie so that a new quiz session can start next time
deleteQuizCookie();


    // cancel any speech synthesis going on
    speechSynthesis.cancel();
    // stop the timer
    stopCountdown();
    // send results to Google Sheets
    appendToGoogleSheet();
    const container = document.querySelector(".container");
    container.innerHTML = "<h1>Scores</h1>";
    for (const student in scores) {
      container.innerHTML += "<p>" + student + ": " + scores[student] + "/" + chances[student] + "</p>";
    }
    displayTeamScores();
    displayChart();
    container.innerHTML += "<footer id='footerText'>Powered by Sourabh Suneja</footer>";
  }

 




// Function to display team scores
  function displayTeamScores() {

   // return back if team map is not available
     if(useteam != 'y' || !teammap) {
           return;
     }

    // First, consolidate the scores and chances consolidateScoresAndChances();


    const container = document.querySelector(".container");
    container.innerHTML += "<h1>Team-wise Scores</h1>";
    for (const team in teamScores) {
      container.innerHTML += "<p>" + team + ": " + teamScores[team] + "/" + teamChances[team] + "</p>";
    }
   
    
  }









  // Initialize quiz when the page loads
  window.onload = initializeQuiz;





// Function to calculate percentage and display chart
  function displayChart() {
    var chartContainer = document.createElement('div');
    chartContainer.classList.add('chart-container');

    var studentData = [];

    // Calculate percentages and store student data
    for (var student in scores) {
      var percentage = (scores[student] / chances[student]) * 100;
      if(usecards == 'y') {
           percentage = (scores[student] / chances[student]).toFixed(2);
console.log(percentage);
      }
      studentData.push({ name: student, percentage: percentage });
    }

    // Sort students based on their percentages (highest to lowest)
    studentData.sort(function(a, b) {
      return b.percentage - a.percentage;
    });

    // Create bars for each student
    studentData.forEach(function(student) {
      var bar = document.createElement('div');
      var shade = Math.round(205 - (student.percentage * 1.55)); // Calculate shade of green
      shade = Math.max(shade, 50); // Ensure a minimum value for visibility
      bar.style.backgroundColor = 'rgb(0,' + '120' + ',0)'; // Set background color
      bar.classList.add('bar');
      bar.style.width = (student.percentage < 0 ? 0 : student.percentage) + '%';
      
      // Create span for text and percentage
      var barText = document.createElement('span');
      barText.classList.add('bar-text');
      barText.textContent = student.name + ': ' + parseFloat(student.percentage).toFixed(2);

      if(usecards != 'y') {
            barText.textContent += '%';
      }

      bar.appendChild(barText);
      
      chartContainer.appendChild(bar);
    });

    document.body.appendChild(chartContainer);

// create download scoresheet button
// Create a button element
var button = document.createElement("button");
// Set button text
button.innerHTML = "Download Scoresheet";
// Set button id
button.id = "downloadBtn";
// Center align the button
button.style.display = "block";
button.style.margin = "auto";

// Append the button to the end of the page body
document.body.appendChild(button);
// Attach click event handler to the button
document.getElementById("downloadBtn").addEventListener("click", function() {
    downloadCSV(false);
});


displayTeamChart();


  }





function speakUp(text, speed) {
    // Cancel previous speech synthesis if there is an ongoing utterance
    if (currentUtterance) {
        speechSynthesis.cancel();
    }

    // Replace underscores with "dash"
    text = text.replace(/_{2,20}/g, "dash");

    // Create a new SpeechSynthesisUtterance instance
    var utterance = new SpeechSynthesisUtterance();

    // Set the modified text to be spoken
    utterance.text = text;

    // Set the Indian English voice
    utterance.voice = speechSynthesis.getVoices().find(function(voice) {
        return voice.lang === 'en-IN';
    });

    // Set the speed of speaking
    utterance.rate = speed || 1.0; // If speed is not specified, default to 1.0

    // Set the initial volume
    utterance.volume = initialVolume / 100; // Map slider volume range (1-100) to SpeechSynthesisUtterance volume range (0-1)

    // Speak the text
    speechSynthesis.speak(utterance);

    // Store the current utterance
    currentUtterance = utterance;
}




// Function to create CSV data
function createCSV(scores, chances) {
  // Create a CSV header
  var csv = "Name, Score, Chance, Percentage\n";
  if(usecards == 'y') {
     csv = "Name, Score, Chance, Efficiency\n";
  }

  // Iterate through the chances object to ensure all names are included
  Object.keys(chances).forEach(function(name) {
    // Get the score for the current name
    var score = scores[name] !== undefined ? scores[name] : 0;
    // Get the chance for the current name
    var chance = chances[name];
   // Calculate percentage
    var percentage = (parseFloat(score)/parseInt(chance)) * 100;
    if(usecards == 'y') {
        percentage = (parseFloat(score)/parseInt(chance));
    }
   // Round off percentage to two decimal places
   percentage = percentage.toFixed(2);
    // Append data to CSV
    csv += name + "," + score + "," + chance + "," + percentage + "\n";
  });

  return csv;
}




// Function to download CSV file
function downloadCSV(teamCSV = false) {
  // Create CSV data
  var csvData, filename;
  if(teamCSV) {
    csvData = createCSV(teamScores, teamChances);
    filename = 'teamscores.csv';
  } else if(teamCSV == false) {
  csvData = createCSV(scores, chances);
  filename = 'scoresheet.csv';
    }
  // Create a Blob object from the CSV data
  var blob = new Blob([csvData], { type: "text/csv;charset=utf-8" });
  // Create a temporary URL for the Blob
  var url = window.URL.createObjectURL(blob);
  // Create a temporary anchor element
  var a = document.createElement("a");
  // Set the href attribute of the anchor to the temporary URL
  a.href = url;
  // Set the download attribute to specify the filename
  a.download = filename;
  // Append the anchor to the body
  document.body.appendChild(a);
  // Click the anchor to trigger download
  a.click();
  // Remove the anchor from the body
  document.body.removeChild(a);
  // Revoke the temporary URL to free up memory
  window.URL.revokeObjectURL(url);
}







// script to handle countdown if required

function startCountdown() {
    let timer = document.getElementById('timer');

    let interval = setInterval(function() {
        if (stopCountDown) {
            clearInterval(interval);
            return;
        }

        let minutes = Math.floor(countdown / 60);
        let seconds = countdown % 60;

        // Add leading zero if necessary
        minutes = minutes < 10 ? '0' + minutes : minutes;
        seconds = seconds < 10 ? '0' + seconds : seconds;

        timer.textContent = minutes + ':' + seconds;

        if (countdown === 0 && !countdownPaused) {
            if (students.length > 1) {
    // programmatically click the pick another student button to give chance to another student in case of group quiz or individual quiz with more than one participant 
    document.getElementById("pickAnotherBtn").click();
} else {
    // move to next question in case of individual quiz with just 1 participant
    let text = document.getElementById('studentName').textContent;

    let index = text.indexOf('for');

    const currentStudent = text.substring(index + 4);


    if (chances[currentStudent] === undefined) {
      chances[currentStudent] = 1;
    } else {
      chances[currentStudent]++;
    }
    nextQuestion(true);
}

            
        } else {
            if(!countdownPaused) {
              countdown--;
            }
        }
    }, 1000);
}

function stopCountdown() {
    stopCountDown = true;
}


function resetCountdown() {
    countdown = countdownDuration;
}


function pauseCountdown() {
  countdownPaused = !countdownPaused;
  countdownPauseStateBeforeMedia = countdownPaused;
  if(countdownPaused) {
    countdown++;
  }
  const button = document.getElementById('pauseBtn');
  button.textContent = countdownPaused ? 'Resume countdown' : 'Pause countdown';
}

  
slider = document.getElementById("volumeRange");
  // Listen for the input event on the slider
slider.addEventListener("input", function() {
    // If there is an ongoing utterance, update its volume
    if (currentUtterance) {
        var volume = this.value; // Get the slider value
        currentUtterance.volume = volume / 100; // Map slider volume range (1-100) to SpeechSynthesisUtterance volume range (0-1)
       speechSynthesis.speak(currentUtterance); // Speak again to apply the new volume

        initialVolume = volume;
    }
});






// script to handle the custom select box
function attachCustomSelect() {
    const pickAnotherBtn = document.getElementById('pickAnotherBtn');
    const studentName = document.getElementById('studentName');
    const students = window.students || []; // Get student names from window.students or default to an empty array
    
    const longPressDelay = 1000; // Long press delay in milliseconds

    let longPressTimer;

    function showCustomDialog() {
        // Create custom dialog box
        const dialogBox = document.createElement('div');
        dialogBox.classList.add('custom-dialog');


        // Dialog box close button
const closeButton = document.createElement('span');
closeButton.classList.add('custom-dialog-close');
closeButton.textContent = 'Ã—';
closeButton.addEventListener('click', function() {
    document.body.removeChild(dialogBox); // Close dialog box
});
dialogBox.appendChild(closeButton);


        // Dialog box title
        const title = document.createElement('div');
        title.classList.add('custom-dialog-title');
        title.textContent = "Select a student";
        dialogBox.appendChild(title);

        // List of options
        const optionsList = document.createElement('ul');
        optionsList.classList.add('custom-dialog-options');

        // Include options from students array only if their chances are left

const filteredStudents = students.filter(student => (maxChances - (chances[student] || 0)) > 0 || !(student in chances));



        filteredStudents.forEach(function(student) {
            const option = document.createElement('li');
            option.textContent = student;
            option.classList.add('custom-dialog-option');
            option.addEventListener('click', function() {


// testing

var text = studentName.textContent;
var index = text.indexOf('for');

const currentStudent = text.substring(index + 4);

// upon custom selection, increase the chance manually for the student who has been replaced by the student picked

if(currentStudent != student) {  


    if (chances[currentStudent] === undefined) {
      chances[currentStudent] = 1;
    } else {
      chances[currentStudent]++;
    }

}

// testing 


                studentName.textContent = "Question for " + student;
                document.getElementById('nameInsideCardPicker').textContent = student;
resetCountdown();
                document.body.removeChild(dialogBox); // Close dialog box
            });
            optionsList.appendChild(option);
        });

        dialogBox.appendChild(optionsList);

        // Append dialog box to body
        document.body.appendChild(dialogBox);
    }

    pickAnotherBtn.addEventListener('mousedown', function(event) {
        longPressTimer = setTimeout(showCustomDialog, longPressDelay); // Start timer for long press
    });

    pickAnotherBtn.addEventListener('mouseup', function() {
        clearTimeout(longPressTimer); // Cancel long press timer if button is released before the specified duration
    });

    pickAnotherBtn.addEventListener('touchstart', function(event) {
        longPressTimer = setTimeout(showCustomDialog, longPressDelay); // Start timer for long press
    });

    pickAnotherBtn.addEventListener('touchend', function() {
        clearTimeout(longPressTimer); // Cancel long press timer if button is released before the specified duration
    });
}





// show scores button handling here
   // Function to calculate percentage
  function calculatePercentage(score, chance) {
    return ((score / chance) * 100).toFixed(2);
  }

  // Function to populate table with scores, chances, and percentage
  function populateTable() {
    var tableBody = document.querySelector('#scoreTable tbody');
    tableBody.innerHTML = '';

    // Combine scores and chances objects to get unique student names
    var students = Array.from(new Set([...Object.keys(scores), ...Object.keys(chances)]));

    // Sort student names in A to Z order
    students.sort();

    students.forEach(function(student) {
      var row = document.createElement('tr');
      var nameCell = document.createElement('td');
      var scoreCell = document.createElement('td');
      var chanceCell = document.createElement('td');
      var percentageCell = document.createElement('td');

      // Check if student is in scores object
      var score = scores[student] || 0;

      nameCell.textContent = student;
      scoreCell.textContent = score;
      chanceCell.textContent = chances[student] || 0;
      percentageCell.textContent = calculatePercentage(score, chances[student] || 1) + '%';

     if(usecards == 'y') {
        percentageCell.textContent = (score/chances[student]).toFixed(2);
     }

      row.appendChild(nameCell);
      row.appendChild(scoreCell);
      row.appendChild(chanceCell);
      row.appendChild(percentageCell);

      tableBody.appendChild(row);
    });
  }

  // Show table when scores button is clicked
  var scoresButton = document.getElementById('scoresButton');
  var scoreTableContainer = document.getElementById('scoreTableContainer');

  scoresButton.addEventListener('click', function() {
   
 scoreTableContainer.style.display = 'block';
    populateTable();
    displayTeamScoresAndChances();
  });

  // Hide table when clicking anywhere outside the table
  window.addEventListener('click', function(event) {
    if (!scoreTableContainer.contains(event.target) && event.target !== scoresButton) {
      scoreTableContainer.style.display = 'none';
    }
  });






// functions to store data of all quiz sessions in cookies for long term retrieval


function storeQuizSession() {
    // Get current date and time
    const currentDate = new Date();
    const dateFormatted = currentDate.toLocaleDateString('en-US', { day: 'numeric', month: 'long', year: 'numeric' });
    const timeFormatted = currentDate.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });

    // Create session object
    const session = {
      'quizTitle': title,
      'date': dateFormatted,
      'time': timeFormatted,
      'scores': scores,
      'chances': chances
    };

    // Get existing allscores cookie or create a new one
    let allScoresCookie = JSON.parse(getCookie('allscores') || '[]');
    
    // Append current session to the array
    allScoresCookie.push(session);

    // Store updated allscores cookie
    document.cookie = `allscores=${JSON.stringify(allScoresCookie)}; expires=Fri, 31 Dec 9999 23:59:59 GMT`;
  }

  // Function to get cookie by name
  function getCookie(name) {
    const cookies = document.cookie.split(';');
    for (let cookie of cookies) {
      const [cookieName, cookieValue] = cookie.split('=');
      if (cookieName.trim() === name) {
        return decodeURIComponent(cookieValue);
      }
    }
    return null;
  }







// code to handle MCQ type questions

function handleMCQ(question) {
  // Regex pattern to identify MCQ-type questions
  const mcqPattern = /\(Options: (.*) Correct: (.*)\)$/i;

  // Test if the question matches the MCQ pattern
  const isMCQ = mcqPattern.test(question);

  // If not an MCQ-type question, return false and remove all option buttons from the DOM
  if (!isMCQ) {
    const optionBtns = document.querySelectorAll('.optionsBtn');
    optionBtns.forEach(btn => btn.remove());
    correctAnsAvailable = false;
    return false;
  }
    
  // Extract question, options, and correct answer using regex
  const [, optionsPart, correctAnswer] = mcqPattern.exec(question);
  const options = optionsPart.split(/Option [A-D]}\s*/).filter(Boolean).map(option => option.trim());

  // Get required DOM elements
  const questionTextNode = document.getElementById('questionText');
  const correctBtn = document.getElementById('correctBtn');
  const incorrectBtn = document.getElementById('incorrectBtn');
  const partiallyCorrectBtn = document.getElementById('partiallyCorrectBtn');
  const buttonsDiv = document.getElementById('optionBtnContainer');



  // Set inner content of questionText
  questionTextNode.innerHTML = question.replace(mcqPattern, '').trim();

  // Hide the buttons
  correctBtn.style.display = 'none';
  incorrectBtn.style.display = 'none';
  partiallyCorrectBtn.style.display = 'none';

  // Remove existing option buttons
  const existingOptionBtns = document.querySelectorAll('.optionsBtn');
  existingOptionBtns.forEach(btn => btn.remove());

  // store correct answer in a global variable
  correctAnsAvailable = correctAnswer.trim()
 
  
  // Create and append option buttons
  options.forEach((option, index) => {
    const btn = document.createElement('button');
    btn.textContent = String.fromCharCode(65+index) + ') ' + ' ' + option.trim();
    btn.classList.add('optionsBtn');
    btn.addEventListener('click', () => {
      if (option.trim() === correctAnswer.trim()) {
        handleCorrectChoice();
      } else {
        handleIncorrectChoice();
      }
    });
    buttonsDiv.append(btn);
  });

  // Function to handle correct choice
  function handleCorrectChoice() {
    correctBtn.click();
  }

  // Function to handle incorrect choice
  function handleIncorrectChoice() {
    incorrectBtn.click();
  }

// Return true after successful handling of MCQ type question
    return true;


}






// code to handle congratulatory or encouraging messages upon answering

    function showAnimation(isCorrect) {

     // disable all non-option buttons while the animation is displayed on the screen
    const nonOptBtns = document.querySelectorAll('.nonOptBtn');
    nonOptBtns.forEach(function(button) {
    button.disabled = true;
    });


      let randomWord = isCorrect ? congratulatoryWords[Math.floor(Math.random() * congratulatoryWords.length)] : encouragingWords[Math.floor(Math.random() * encouragingWords.length)];

// in case of partially correct answers
if (isCorrect === 0.5) {
    randomWord = partiallyCorrectWords[Math.floor(Math.random() * partiallyCorrectWords.length)];
}


      const animationDiv = document.createElement('div');

      if(correctAnsAvailable && !isCorrect) {
        animationDiv.textContent = 'No. The correct answer is: ' + correctAnsAvailable;
        if(ansExplanation) {
             animationDiv.innerHTML += "<br>" + ansExplanation;
        }
      } 
      else if(ansExplanation && !isCorrect) {
             animationDiv.innerHTML = randomWord + "<br><br>" + "Correct answer:" + "<br>" + ansExplanation;
      }
      else if(isCorrect == 0.5 && ansExplanation) {
          animationDiv.innerHTML = "Good try! But the exact answer is: " + "<br>" + ansExplanation;
      }
      else {
      animationDiv.textContent = randomWord;
      }
      animationDiv.classList.add('animation');
      if (isCorrect === 0.5) {
    animationDiv.classList.add('half-correct');
} else {
    animationDiv.classList.add(isCorrect ? 'correct' : 'wrong');
}

   // add class animation-fs-reduced in case the length of the explanation is too long, so as to make it adjust on small screens

   if (animationDiv.textContent.length > 120) {
  animationDiv.classList.add('animation-fs-reduced');
}

      animationContainer.innerHTML = '';
      animationContainer.appendChild(animationDiv);
      animationContainer.style.display = 'block';
      
    }



function showAnswerAnimation() {

     // disable all non-option buttons while the animation is displayed on the screen
    const nonOptBtns = document.querySelectorAll('.nonOptBtn');
    nonOptBtns.forEach(function(button) {
    button.disabled = true;
    });


      const animationDiv = document.createElement('div');
      animationDiv.textContent = '';

      if(correctAnsAvailable) {
        animationDiv.textContent = 'The correct answer is: ' + correctAnsAvailable;
      } 

      if(ansExplanation) {
             animationDiv.innerHTML += ((correctAnsAvailable)? "<br>" : "") + ansExplanation;
        }

      if(!correctAnsAvailable && !ansExplanation) {
        animationDiv.textContent = "I'm sorry. No correct answer or explanation was provided to me for this question.";
      } 

      
      animationDiv.classList.add('animation');
      animationDiv.classList.add('answer');

   // add class animation-fs-reduced in case the length of the explanation is too long, so as to make it adjust on small screens

   if (animationDiv.textContent.length > 120) {
  animationDiv.classList.add('animation-fs-reduced');
}

      animationContainer.innerHTML = '';
      animationContainer.appendChild(animationDiv);
      animationContainer.style.display = 'block';

    }



// script to handle additionally embedded JSON parameters and media-based operations

function playMedia(mediaType, link, startTime = 0, endTime = 0) {
    var container = document.getElementById('mediaContainer');
    container.style.display = 'block';
    

   // increase number of times played
 timesMediaPlayed[currentQuestionIndex]++;

    if (player) {
      player.destroy();
    }

    if(mediaType === 'image') {
      showMediaImage(link);
    }

    else if (mediaType === 'video') {
      player = new YT.Player('player', {
        height: '100%',
        width: '100%',
        videoId: getVideoId(link),
        playerVars: {
          'autoplay': 1,
          'start': startTime,
          'end': endTime,
          'controls': 0,
          'fs': 1,
          'showinfo': 0,
          'iv_load_policy': 3
        },
        events: {
          'onReady': function(event) {
            event.target.playVideo();
            document.getElementById('audioText').style.display = 'none';
          },
          'onStateChange': function(event) {
            if (event.data === YT.PlayerState.ENDED) {
              hideMediaContainer();
            }
          }
        }
      });
    } else if (mediaType === 'audio') {
      player = new YT.Player('player', {
        height: '0',
        width: '0',
        videoId: getVideoId(link),
        playerVars: {
          'autoplay': 1,
          'start': startTime,
          'end': endTime,
          'controls': 0,
          'fs': 1
        },
        events: {
          'onReady': function(event) {
            event.target.playVideo();
            document.getElementById('audioText').style.display = 'block';
          },
          'onStateChange': function(event) {
            if (event.data === YT.PlayerState.ENDED) {
              hideMediaContainer();
            }
          }
        }
      });
    }
  }

  function hideMediaContainer() {
    const container = document.getElementById('mediaContainer');
    const buttonsDiv = document.getElementById('optionBtnContainer');
    const showAnsBtn = document.getElementById('showAnsBtn');
    container.style.display = 'none';
    buttonsDiv.style.display = 'block';
    showAnsBtn.style.display = 'block';
    document.getElementById('audioText').style.display = 'none';
    if (player) {
      player.destroy();
    }

    var image = container.querySelector('img');
    if (image) {
        container.removeChild(image);
    }
    var loadingAnimation = container.querySelector('.loading-animation');
    if (loadingAnimation) {
        container.removeChild(loadingAnimation);
    }

    // resume countdown
    countdownPaused = countdownPauseStateBeforeMedia;
  }



  function getVideoId(link) {
    var regExp = /^.*(?:youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|\&v=)([^#\&\?]*).*/;
    var match = link.match(regExp);
    if (match && match[1].length === 11) {
      return match[1];
    } else {
      console.error('Invalid YouTube URL');
    }
  }

// function to extract the JSON parameters from question string
function extractJSONFromString(inputString) {
    const jsonStartIndex = inputString.indexOf('JSONParams:');
    if (jsonStartIndex === -1) {
        return null; // JSON part not found in the string
    }

    const jsonString = inputString.substring(jsonStartIndex + 'JSONParams:'.length);
    const trimmedJsonString = jsonString.trim();
    const firstCurlyBraceIndex = trimmedJsonString.indexOf('{');
    const lastCurlyBraceIndex = trimmedJsonString.lastIndexOf('}');
    if (firstCurlyBraceIndex === -1 || lastCurlyBraceIndex === -1) {
        console.error('Error: Invalid JSON structure');
        return null;
    }

    const jsonSubstring = trimmedJsonString.substring(firstCurlyBraceIndex, lastCurlyBraceIndex + 1);
    try {
        const jsonObject = JSON.parse(jsonSubstring);
        return jsonObject;
    } catch (error) {
        console.error('Error parsing JSON:', error);
        return null;
    }
}

// function to extract the question string before the JSONParams part
function extractStringBeforeJSON(inputString) {
    const jsonStartIndex = inputString.indexOf('JSONParams:');
    if (jsonStartIndex === -1) {
        return inputString; 
    }
    
    return inputString.substring(0, jsonStartIndex);
}


function showMediaImage(imageUrl) {
    var container = document.getElementById('mediaContainer');

    // Create and append the loading animation
    var loadingAnimation = document.createElement('div');
    loadingAnimation.className = 'loading-animation';
    container.appendChild(loadingAnimation);

    // Create and append the image
    var image = new Image();
    image.src = imageUrl;
    image.onload = function() {
        // Remove loading animation
        container.removeChild(loadingAnimation);

        // Calculate the maximum width and height
        var maxWidth = container.offsetWidth;
        var maxHeight = container.offsetHeight;

        // Set image width and height to its original dimensions or the container's maximum dimensions, whichever is smaller
        if (image.width > maxWidth || image.height > maxHeight) {
            var widthRatio = maxWidth / image.width;
            var heightRatio = maxHeight / image.height;
            var ratio = Math.min(widthRatio, heightRatio);
            image.width = image.width * ratio;
            image.height = image.height * ratio;
        }

        // Set image position to the middle of the container
        image.style.top = '50%';
        image.style.left = '50%';
        image.style.transform = 'translate(-50%, -50%)';

        // Append the image
        container.appendChild(image);
       // Set timeout to close the media container after 5 seconds
      setTimeout(hideMediaContainer, 5000);
    };

    image.onerror = function() {
        // Remove loading animation
        container.removeChild(loadingAnimation);

        // Display "Failed to load image"
        alert('Failed to load image');
    };
}


// function to wait for click before proceeding to the next question, after a promise is returned
function waitForClick() {
  return new Promise(resolve => {
    setTimeout(() => {
      function clickHandler() {

     if (event.target.id !== 'scoresButton') {
        document.body.removeEventListener('click', clickHandler);
        resolve();
     }

      }
      
      document.body.addEventListener('click', clickHandler);
    }, 500); // Adjust the delay time as needed
  });
}



// Function to programmatically trigger a click on the page in order to proceed to next question automatically
function triggerClick() {
  // Simulate a click event on the document body
  const event = new Event('click');
  document.body.dispatchEvent(event);
}




// script to handle cards

let activeIndex = -1;

  function activateCard(index) {
    playFunction('pop');
    const carousel = document.querySelector('.carousel');
    const items = document.querySelectorAll('.carousel-item');
    
    // Remove the active class from all items
    items.forEach((item, i) => {
      item.classList.remove('active');
      if (i === index) {
        item.classList.add('active');
      }
    });
    
    // Calculate the new transform value
    const itemWidth = items[index].offsetWidth;
    const offset = itemWidth * index + 20 * index; // 20 is the margin between items
    
    // Adjust the transform property to bring the active item into view
    const containerWidth = document.querySelector('.carousel-container').offsetWidth;
    const centerOffset = (containerWidth - itemWidth) / 2;
    const totalOffset = offset - centerOffset;

    // Ensure the first item is fully visible
    const finalOffset = Math.max(totalOffset, 0);
    carousel.style.transform = `translateX(-${finalOffset}px)`;

   toggleSelectCardBtn();

  }



// function to fetch the weightage of the selected card and return value as promise
function selectCard() {
    return new Promise((resolve, reject) => {
        
        // Get the button element
        const selectCardBtn = document.getElementById('selectCardBtn');

        // Function to handle the click event
        function selectCardBtnClickListener() {
            // Resolve the promise with the value of cardWeightage
            resolve(getCardWeightage());

            // close the card picker after a card has been picked
            closeCardPicker();
            
            // Remove the click event listener after resolving the promise
            selectCardBtn.removeEventListener('click', selectCardBtnClickListener);
            
        }
        
        // Add click event listener to the button
        selectCardBtn.addEventListener('click', selectCardBtnClickListener);
    });
}



// function to close card picker
function closeCardPicker() {
    document.getElementById('card-picker').style.display = 'none';
}





function getCardWeightage() {

// Get the carousel element
        const carouselInner = document.querySelector('.carousel');
        
        // Find the active div within the carousel
        const activeDiv = carouselInner.querySelector('.active');
        
        // Get the data-points attribute of the active div
        const dataPoints = activeDiv.getAttribute('data-points');
        
        // Convert data-points to an integer
        cardWeightage = parseInt(dataPoints);

        return cardWeightage;

}


// function to extract card indices from questions
function extractCardIndices() {
  // Step 1: Map each element of "questions" array with extractJSONFromString
  const extractedObjects = questions.map(extractJSONFromString);
  
  // Step 2 & 3: Iterate over all JSON objects, extract "card" key values, and create object with unique card values and their indices
  const cardIndices = {};
  extractedObjects.forEach((obj, index) => {
    if (obj && obj.hasOwnProperty('card')) {
      const cardValue = obj.card;
      if (!cardIndices.hasOwnProperty(cardValue)) {
        cardIndices[cardValue] = [];
      }
      cardIndices[cardValue].push(index);
    }
  });

  return cardIndices;
}


// function to get a random question index corresponding to the card selected
function getRandomItemAndRemove(cardValue) {
  // Check if the cardValue exists in cardIndices and has a non-empty array
  if (cardIndices.hasOwnProperty(cardValue) && cardIndices[cardValue].length > 0) {
    // Get a random index from the array
    const randomIndex = Math.floor(Math.random() * cardIndices[cardValue].length);
    
    // Get the random item from the array
    const randomItem = cardIndices[cardValue][randomIndex];
    
    // Remove the random item without leaving gaps
    cardIndices[cardValue].splice(randomIndex, 1);

    // If the array becomes empty after removal, delete the key
    if (cardIndices[cardValue].length === 0) {
      delete cardIndices[cardValue];
    }

    // Return the random item
    return randomItem;
  } else {
    // If the key is not found or the array is empty, return null
    return null;
  }
}


// function to filter carousel items (cards) based on availability of questions
function filterCarouselItems() {
  // Get all carousel items
  const carouselItems = document.querySelectorAll('.carousel-item');

  // Variable to track if any item is visible
  let isVisible = false;

  // Iterate over each carousel item
  carouselItems.forEach(item => {
    // Get the card value from data-points attribute
    const cardValue = item.dataset.points;

    // Check if the card value exists in cardIndices keys
    if (cardIndices.hasOwnProperty(cardValue)) {
      // Remove hidden class
      item.classList.remove('hidden');
     // Specify number of questions remaining
     item.querySelector('.cardQRemaining').innerText = cardIndices[cardValue].length + (cardIndices[cardValue].length === 1 ? " question" : " questions") + " remaining";
    } else {
      // Add hidden class
      item.classList.add('hidden');
      // Specify no questions available
      item.querySelector('.cardQRemaining').innerText = "No questions available";
    }
  });

}





// function to open card picker
function openCardPicker() {
    document.querySelectorAll('.carousel-item.active').forEach(item => item.classList.remove('active'));
    document.getElementById('selectCardBtn').disabled = true;
    filterCarouselItems();
    document.getElementById('card-picker').style.display = 'block';
}


// function to toggle the activeness of the select card button
function toggleSelectCardBtn() {
    var activeCarouselItem = document.querySelector('.carousel-item.active');
    var selectCardBtn = document.getElementById('selectCardBtn');

    if (!activeCarouselItem || activeCarouselItem.classList.contains('hidden')) {
        selectCardBtn.disabled = true;
    } else {
        selectCardBtn.disabled = false;
    }
}






function saveSession(student) {
   // remove invalid keys, if any
removeKeysWithNobodyOrNoOne();

// re-consolidate team scores before creating cookie
consolidateScoresAndChances();

 storeQuizData(student.trim());
}




</script>


  <script>
    // Show the overlay when data is being submitted
    function srShowOverlay() {
      document.getElementById("sr-loadingOverlay").style.display = "flex";
    }

    // Hide the overlay when data submission is done
    function srHideOverlay() {
      document.getElementById("sr-loadingOverlay").style.display = "none";
    }

// Function to call Google Apps Script to append data to the sheet
function appendToGoogleSheet() {

  // if quiz ID not available, do not post results to Google Sheets
  if(!quizID) {
    return;
  }
  srShowOverlay(); // Show overlay when the submission starts

  
  // Unique Quiz Identifier
  let quizIdentifier = quizID;
  
  // Create an array of participants' data
  let participantsData = Object.keys(scores).map(participant => {
    let score = scores[participant];
    let chance = chances[participant];
    let timestamp = new Date().toLocaleString("en-IN", {
      timeZone: "Asia/Kolkata",
      day: 'numeric',
      month: 'long',
      year: 'numeric',
      hour: 'numeric',
      minute: 'numeric',
      hour12: true
    });

    // Return participant data with quiz identifier
    return {
      name: participant,
      grade: grade,
      section: section,
      score: score,
      chances: chance,
      time: timestamp,
      quizId: quizIdentifier
    };
  });

  // Send all data in one POST request
  fetch('https://script.google.com/macros/s/AKfycbzFDI1jbJeJSzYapgvJ5sT7y2wO5hTIcCzjeUyr2rQU_QQ-tTkUgiMH--MPWGFyhbEq/exec', {
    method: 'POST',
    body: JSON.stringify(participantsData), // Send the array of participants' data
    headers: {
      'Content-Type': 'application/json'
    },
    mode: 'no-cors'
  }).then(response => response.text())
    .then(() => {
      srHideOverlay(); // Hide overlay when submission is complete
    })
    .catch(error => {
      srHideOverlay(); // Hide overlay even in case of an error
      console.error("Failed to submit results:", error);
    });
}
  </script>

<!-- Include the YouTube iframe API -->
<script src="https://www.youtube.com/iframe_api"></script>

</body>
</html>
